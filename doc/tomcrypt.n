.\" Automatically generated by Pandoc 3.1.3
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "tomcrypt" "3" "" "0.8.2" "libtomcrypt Tcl wrapper"
.hy
.SH TOMCRYPT
.PP
libtomcrypt Tcl wrapper - use cryptographic primitives in Tcl scripts
.SS SYNOPSIS
.PP
\f[B]package require tomcrypt\f[R] ?0.8.2?
.PP
\f[B]tomcrypt::hash\f[R] \f[I]algorithm\f[R] \f[I]bytes\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::hmac\f[R] \f[I]algorithm\f[R] \f[I]key\f[R]
\f[I]message\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::hkdf\f[R] \f[I]algorithm\f[R] \f[I]salt\f[R]
\f[I]info\f[R] \f[I]in\f[R] \f[I]length\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::base64url\f[R] \f[B]encode\f[R]|\f[B]strict_encode\f[R]
\f[I]bytes\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::base64url\f[R] \f[B]decode\f[R]|\f[B]strict_decode\f[R]
\f[I]string\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::encrypt\f[R] \f[I]spec\f[R] \f[I]key\f[R] \f[I]iv\f[R]
\f[I]bytes\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::decrypt\f[R] \f[I]spec\f[R] \f[I]key\f[R] \f[I]iv\f[R]
\f[I]bytes\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::ecc_generate_key\f[R] \f[I]curve\f[R] ?\f[I]prng\f[R]?
.PD 0
.P
.PD
\f[B]tomcrypt::ecc_extract_pubkey\f[R] \f[I]privkey\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::ecc_ansi_x963_import\f[R] \f[I]bytes\f[R]
?\f[I]curve\f[R]?
.PD 0
.P
.PD
\f[B]tomcrypt::ecc_ansi_x963_export\f[R] \f[I]pubkey\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::ecc_verify\f[R] \f[I]sig\f[R] \f[I]message\f[R]
\f[I]pubkey\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::ecc_sign\f[R] \f[I]privkey\f[R] \f[I]message\f[R]
?\f[I]prng\f[R]?
.PD 0
.P
.PD
\f[B]tomcrypt::ecc_shared_secret\f[R] \f[I]privkey\f[R] \f[I]pubkey\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::rsa_make_key\f[R] ?\f[B]-keysize\f[R] \f[I]bits\f[R]?
?\f[B]-exponent\f[R] \f[I]e\f[R]?
?\f[B]-prng\f[R] \f[I]prng\f[R]?
.PD 0
.P
.PD
\f[B]tomcrypt::rsa_extract_pubkey\f[R] \f[I]privkey\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::rsa_sign_hash\f[R] \f[B]-key\f[R] \f[I]privkey\f[R]
\f[B]-hash\f[R] \f[I]hash\f[R] ?\f[B]-padding\f[R] \f[I]type\f[R]?
?\f[B]-hashalg\f[R] \f[I]algorithm\f[R]?
?\f[B]-saltlen\f[R] \f[I]bytes\f[R]?
?\f[B]-prng\f[R] \f[I]prng\f[R]?
.PD 0
.P
.PD
\f[B]tomcrypt::rsa_verify_hash\f[R] \f[B]-key\f[R] \f[I]pubkey\f[R]
\f[B]-sig\f[R] \f[I]signature\f[R] \f[B]-hash\f[R] \f[I]hash\f[R]
?\f[B]-padding\f[R] \f[I]type\f[R]?
?\f[B]-hashalg\f[R] \f[I]algorithm\f[R]?
?\f[B]-saltlen\f[R] \f[I]bytes\f[R]?
.PD 0
.P
.PD
\f[B]tomcrypt::rsa_encrypt_key\f[R] \f[B]-key\f[R] \f[I]pubkey\f[R]
\f[B]-msg\f[R] \f[I]message\f[R] ?\f[B]-padding\f[R] \f[I]type\f[R]?
?\f[B]-hashalg\f[R] \f[I]algorithm\f[R]?
?\f[B]-lparam\f[R] \f[I]label\f[R]?
?\f[B]-prng\f[R] \f[I]prng\f[R]?
.PD 0
.P
.PD
\f[B]tomcrypt::rsa_decrypt_key\f[R] \f[B]-key\f[R] \f[I]privkey\f[R]
\f[B]-ciphertext\f[R] \f[I]ciphertext\f[R] ?\f[B]-padding\f[R]
\f[I]type\f[R]?
?\f[B]-hashalg\f[R] \f[I]algorithm\f[R]?
?\f[B]-lparam\f[R] \f[I]label\f[R]?
.PD 0
.P
.PD
\f[B]tomcrypt::rng_bytes\f[R] \f[I]count\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::prng\f[R] \f[B]create\f[R] \f[I]prngInstance\f[R]
\f[I]type\f[R] ?\f[I]entropy\f[R]?
.PD 0
.P
.PD
\f[B]tomcrypt::prng\f[R] \f[B]new\f[R] \f[I]type\f[R]
?\f[I]entropy\f[R]?
.PP
PRNG instance methods:
.PP
\f[I]prngInstance\f[R] \f[B]bytes\f[R] \f[I]count\f[R]
.PD 0
.P
.PD
\f[I]prngInstance\f[R] \f[B]add_entropy\f[R] \f[I]entropy\f[R]
.PD 0
.P
.PD
\f[I]prngInstance\f[R] \f[B]integer\f[R] \f[I]lower\f[R] \f[I]upper\f[R]
.PD 0
.P
.PD
\f[I]prngInstance\f[R] \f[B]double\f[R]
.PD 0
.P
.PD
\f[I]prngInstance\f[R] \f[B]export\f[R]
.PD 0
.P
.PD
\f[I]prngInstance\f[R] \f[B]destroy\f[R]
.SS DESCRIPTION
.PP
This package provides a thin wrapper around a subset of
libtomcrypt\[cq]s functionality.
.SS COMMANDS
.TP
\f[B]tomcrypt::hash\f[R] \f[I]algorithm\f[R] \f[I]bytes\f[R]
Return the hash of \f[I]bytes\f[R], using the \f[I]algorithm\f[R].
The values available for \f[I]algorithm\f[R] are those that are known by
libtomcrypt.
The returned value is the raw bytearray.
.TP
\f[B]tomcrypt::hmac\f[R] \f[I]algorithm\f[R] \f[I]key\f[R] \f[I]message\f[R]
Compute the HMAC (Hash-based Message Authentication Code) of
\f[I]message\f[R] using the hash \f[I]algorithm\f[R] and \f[I]key\f[R].
The \f[I]algorithm\f[R] must be one of the hash algorithms known to
libtomcrypt (like sha256).
Both \f[I]key\f[R] and \f[I]message\f[R] must be byte arrays.
Returns the HMAC result as a raw byte array.
.TP
\f[B]tomcrypt::hkdf\f[R] \f[I]algorithm\f[R] \f[I]salt\f[R] \f[I]info\f[R] \f[I]in\f[R] \f[I]length\f[R]
Perform HKDF (HMAC-based Extract-and-Expand Key Derivation Function)
using the specified \f[I]algorithm\f[R] (a hash algorithm known to
libtomcrypt, like sha256), with the given \f[I]salt\f[R] (a bytearray,
can be empty), \f[I]info\f[R] (a bytearray, can be empty), and input
keying material \f[I]in\f[R] (a bytearray).
The derived key will be \f[I]length\f[R] bytes long.
Returns the derived key as a raw bytearray.
.TP
\f[B]tomcrypt::base64url\f[R] \f[B]encode\f[R]|\f[B]strict_encode\f[R] \f[I]bytes\f[R]
Return the base64url encoding of \f[I]bytes\f[R], which is the same as
the regular base64 encoding except for two substitutions: `+' -> `-' and
`/' -> `_', so that the result can be represented in a URL part without
needing to be escaped.
Also useful when using the result as a filename.
If \f[B]strict_encode\f[R] is used, then the result will have `='
padding characters appended to ensure that its length is a multiple of
4.
\f[B]encode\f[R] does not pad its output.
.TP
\f[B]tomcrypt::base64url\f[R] \f[B]decode\f[R]|\f[B]strict_decode\f[R] \f[I]string\f[R]
Inverts the encoding applied by \f[B]encode\f[R] or
\f[B]strict_encode\f[R].
Both \f[B]decode\f[R] and \f[B]strict_decode\f[R] accept both padded and
unpadded input, but strict does not allow pad characters or characters
outside of the valid base64url alphabet within the encoded value.
.TP
\f[B]tomcrypt::encrypt\f[R] \f[I]spec\f[R] \f[I]key\f[R] \f[I]iv\f[R] \f[I]data\f[R]
Encrypt the plaintext bytes in \f[I]data\f[R] using the key
\f[I]key\f[R] using the cipher and mode specified in \f[I]spec\f[R].
See \f[B]CIPHER SPEC\f[R] for details.
.TP
\f[B]tomcrypt::decrypt\f[R] \f[I]spec\f[R] \f[I]key\f[R] \f[I]iv\f[R] \f[I]data\f[R]
Decrypt the ciphertext bytes in \f[I]data\f[R] using the key
\f[I]key\f[R] using the cipher and mode specified in \f[I]spec\f[R].
See \f[B]CIPHER SPEC\f[R] for details.
.TP
\f[B]tomcrypt::aead\f[R] \f[B]encrypt\f[R] \f[I]mode\f[R] \f[I]cipher\f[R] \f[I]key\f[R] \f[I]iv\f[R] \f[I]aad\f[R] \f[I]plaintext\f[R]
Encrypt \f[I]plaintext\f[R] using authenticated encryption with
associated data (AEAD).
The \f[I]mode\f[R] can be one of: \f[B]gcm\f[R], \f[B]eax\f[R],
\f[B]ocb\f[R], \f[B]ocb3\f[R], \f[B]ccm\f[R], or
\f[B]chacha20poly1305\f[R].
Most modes require a \f[I]cipher\f[R] (like \[lq]aes\[rq]), except
chacha20poly1305 which uses its own cipher (pass \[lq]\[rq] for cipher
in that case).
The \f[I]key\f[R], initialization vector \f[I]iv\f[R], and additional
authenticated data \f[I]aad\f[R] are all byte arrays.
\f[I]aad\f[R] can be empty if no metadata needs to be authenticated.
Returns a 2-element list: {ciphertext tag} where tag is the
authentication tag (typically 16 bytes).
.TP
\f[B]tomcrypt::aead\f[R] \f[B]decrypt\f[R] \f[I]mode\f[R] \f[I]cipher\f[R] \f[I]key\f[R] \f[I]iv\f[R] \f[I]aad\f[R] \f[I]ciphertext\f[R] \f[I]tag\f[R]
Decrypt \f[I]ciphertext\f[R] using AEAD, verifying the authentication
\f[I]tag\f[R].
Parameters must match those used during encryption.
Returns the plaintext if successful, or throws an error if the tag
verification fails (indicating tampering or corruption).
.TP
\f[B]tomcrypt::ecc_generate_key\f[R] \f[I]curve\f[R] ?\f[I]prng\f[R]?
Generate a new ECC key using the PRNG instance \f[I]prng\f[R]
(defaulting to the system PRNG if not specified), using the specified
\f[I]curve\f[R].
See \f[B]CURVE SPEC\f[R] for details of how to specify the curve.
Returns the private key in PEM formatted OpenSSL compatible DER format.
.TP
\f[B]tomcrypt::ecc_extract_pubkey\f[R] \f[I]privkey\f[R]
Extract the public key from an ECC private key \f[I]privkey\f[R] (in
OpenSSL\[cq]s DER format, possibly PEM encoded, as returned by
\f[B]ecc_generate_key\f[R]).
Returns the public key in OpenSSL DER format, PEM encoded.
.TP
\f[B]tomcrypt::ecc_verify\f[R] \f[I]sig\f[R] \f[I]message\f[R] \f[I]pubkey\f[R]
Verify the signature \f[I]sig\f[R] over the message \f[I]message\f[R]
with public key \f[I]pubkey\f[R].
\f[I]sig\f[R] is in ANSI X9.62 format, \f[I]pubkey\f[R] is in ANSI X9.63
section 4.3.6 format or the native libtomcrypt format, and message is
the raw bytearray (typically a hash result) that was signed.
Returns true if the signature is valid, false if not, and throws an
error if it couldn\[cq]t parse \f[I]sig\f[R] or \f[I]pubkey\f[R].
.TP
\f[B]tomcrypt::ecc_sign\f[R] \f[I]privkey\f[R] \f[I]message\f[R] ?\f[I]prng\f[R]?
Sign \f[I]message\f[R] using the private key \f[I]privkey\f[R] (in
openssl\[cq]s DER format (possibly PEM encoded), as returned by
\f[B]ecc_generate_key\f[R]).
If \f[I]prng\f[R] is provided, use that PRNG instance for the signing
operation, otherwise use the system\[cq]s secure random number
generator.
Returns the signature in ANSI X9.62 format, suitable for verification
with \f[B]ecc_verify\f[R].
.TP
\f[B]tomcrypt::ecc_shared_secret\f[R] \f[I]privkey\f[R] \f[I]pubkey\f[R]
Compute an ECDH shared secret between the local private key
\f[I]privkey\f[R] and the remote public key \f[I]pubkey\f[R].
Both parties compute the same shared secret value, which can be used to
derive encryption keys.
Returns the raw x-coordinate of the shared elliptic curve point in
binary format (conforms to EC-DH from ANSI X9.63).
The shared secret should be passed through a key derivation function
like \f[B]hkdf\f[R] before being used as a key.
.TP
\f[B]tomcrypt::rsa_make_key\f[R] ?\f[B]-keysize\f[R] \f[I]bits\f[R]? ?\f[B]-exponent\f[R] \f[I]e\f[R]? ?\f[B]-prng\f[R] \f[I]prng\f[R]?
Generate a new RSA keypair.
The \f[B]-keysize\f[R] option specifies the key size in bits (must be a
multiple of 8 between 1024 and 4096, defaults to 2048).
The \f[B]-exponent\f[R] option sets the public exponent (defaults to
0x10001).
The \f[B]-prng\f[R] option specifies a PRNG instance to use; if omitted,
the system\[cq]s secure random number generator is used.
Returns the private key in PKCS#1 PEM format.
The private key is suitable for use with \f[B]rsa_sign_hash\f[R] and
\f[B]rsa_decrypt_key\f[R].
Use \f[B]rsa_extract_pubkey\f[R] to derive the corresponding public key
for use with \f[B]rsa_verify_hash\f[R] and \f[B]rsa_encrypt_key\f[R].
.TP
\f[B]tomcrypt::rsa_extract_pubkey\f[R] \f[I]privkey\f[R]
Extract the public key from an RSA private key \f[I]privkey\f[R] (in
PKCS#1 DER/PEM format).
Returns the public key in PKCS#1 PEM format, suitable for use with
\f[B]rsa_verify_hash\f[R] and \f[B]rsa_encrypt_key\f[R].
.TP
\f[B]tomcrypt::ecc_ansi_x963_import\f[R] \f[I]bytes\f[R] ?\f[I]curve\f[R]?
Import an ECC public key from ANSI X9.63 section 4.3.6 format (a
bytearray starting with 0x04 followed by the x and y coordinates).
If \f[I]curve\f[R] is provided, it specifies the curve to use (see
\f[B]CURVE SPEC\f[R]), otherwise the curve is inferred from the length
of the x and y coordinates (only works with uncompressed format).
Returns the public key suitable for use with \f[B]ecc_verify\f[R] and
\f[B]ecc_shared_secret\f[R].
.TP
\f[B]tomcrypt::ecc_ansi_x963_export\f[R] \f[I]pubkey\f[R]
Export an ECC public key \f[I]pubkey\f[R] to ANSI X9.63 section 4.3.6
format (a bytearray starting with 0x04 followed by the x and y
coordinates).
.TP
\f[B]tomcrypt::rsa_sign_hash\f[R] \f[B]-key\f[R] \f[I]privkey\f[R] \f[B]-hash\f[R] \f[I]hash\f[R] ?\f[B]-padding\f[R] \f[I]type\f[R]? ?\f[B]-hashalg\f[R] \f[I]algorithm\f[R]? ?\f[B]-saltlen\f[R] \f[I]bytes\f[R]? ?\f[B]-prng\f[R] \f[I]prng\f[R]?
Sign a message hash using the RSA private key \f[I]privkey\f[R] (in
PKCS#1 DER/PEM format, as returned by \f[B]rsa_make_key\f[R] or from
other sources).
The \f[I]hash\f[R] should be the raw bytes of a message digest.
The \f[B]-padding\f[R] option specifies the padding scheme:
\f[B]v1.5\f[R] for PKCS#1 v1.5, \f[B]pss\f[R] for PSS (default), or
\f[B]v1.5_na1\f[R] for v1.5 without ASN.1 encoding (for SSL 3.0
compatibility).
The \f[B]-hashalg\f[R] option only applies to \f[B]pss\f[R] and is the
name of the hash function to use for that padding (e.g., \[lq]sha1\[rq],
\[lq]sha256\[rq], defaults to \[lq]sha256\[rq]).
For PSS padding, \f[B]-saltlen\f[R] specifies the salt length in bytes
(defaults to 0).
If \f[B]-prng\f[R] is provided, use that PRNG instance, otherwise use
the system\[cq]s secure RNG (only applicable to \f[B]pss\f[R]).
Returns the signature as raw bytes.
.TP
\f[B]tomcrypt::rsa_verify_hash\f[R] \f[B]-key\f[R] \f[I]pubkey\f[R] \f[B]-sig\f[R] \f[I]signature\f[R] \f[B]-hash\f[R] \f[I]hash\f[R] ?\f[B]-padding\f[R] \f[I]type\f[R]? ?\f[B]-hashalg\f[R] \f[I]algorithm\f[R]? ?\f[B]-saltlen\f[R] \f[I]bytes\f[R]?
Verify an RSA signature \f[I]signature\f[R] over the message hash
\f[I]hash\f[R] using the public key \f[I]pubkey\f[R] (in PKCS#1 DER/PEM
format).
The \f[B]-padding\f[R] (defaults to \[lq]pss\[rq]), \f[B]-hashalg\f[R]
(defaults to \[lq]sha256\[rq]), and \f[B]-saltlen\f[R] (defaults to 0)
options must match those used during signing.
Returns true if the signature is valid, false otherwise.
.TP
\f[B]tomcrypt::rsa_encrypt_key\f[R] \f[B]-key\f[R] \f[I]pubkey\f[R] \f[B]-msg\f[R] \f[I]message\f[R] ?\f[B]-padding\f[R] \f[I]type\f[R]? ?\f[B]-hashalg\f[R] \f[I]algorithm\f[R]? ?\f[B]-lparam\f[R] \f[I]label\f[R]? ?\f[B]-prng\f[R] \f[I]prng\f[R]?
Encrypt a short message using the RSA public key \f[I]pubkey\f[R] (in
PKCS#1 DER/PEM format).
The \f[B]-padding\f[R] option can be \f[B]v1.5\f[R] for PKCS#1 v1.5 or
\f[B]oaep\f[R] for OAEP padding (default).
For OAEP, the \f[B]-hashalg\f[R] option (only applicable for
\f[B]oaep\f[R] specifies the hash to use (defaults to \[lq]sha256\[rq])
he \f[B]-lparam\f[R] option is an optional label for OAEP (can be empty
bytes).
If \f[B]-prng\f[R] is provided, use that PRNG instance, otherwise use
the system\[cq]s secure RNG.
Returns the encrypted bytes.
Message size limits depend on key size and padding: for a 2048-bit key
with OAEP/SHA-256, the maximum message size is about 190 bytes.
.TP
\f[B]tomcrypt::rsa_decrypt_key\f[R] \f[B]-key\f[R] \f[I]privkey\f[R] \f[B]-ciphertext\f[R] \f[I]ciphertext\f[R] ?\f[B]-padding\f[R] \f[I]type\f[R]? ?\f[B]-hashalg\f[R] \f[I]algorithm\f[R]? ?\f[B]-lparam\f[R] \f[I]label\f[R]?
Decrypt RSA-encrypted data using the private key \f[I]privkey\f[R] (in
PKCS#1 DER/PEM format).
The \f[B]-padding\f[R] (defaults to \[lq]oaep\[rq]), \f[B]-hashalg\f[R]
(defaults to \[lq]sha256\[rq]), and \f[B]-lparam\f[R] options must match
those used during encryption.
Returns the decrypted message bytes, or throws an error if decryption
fails or padding is invalid.
.TP
\f[B]tomcrypt::prng\f[R] \f[B]create\f[R] \f[I]prngInstance\f[R] \f[I]type\f[R] ?\f[I]entropy\f[R]?
Create a PRNG (pseudorandom number generator) instance accessed by the
command name \f[I]prngInstance\f[R], using the implementation
\f[I]type\f[R], such as \f[B]fortuna\f[R] or \f[B]chacha20\f[R] (as
known to libtomcrypt), or \[lq]\[rq] (an empty string) to select the
recommended default which may change between releases, and bootstrapped
with \f[I]entropy\f[R] which must be a bytearray of high entropy bytes.
If \f[I]entropy\f[R] is omitted the PRNG will be bootstrapped with at
least 256 bits of entropy from the platform\[cq]s default cryptographic
RNG.
Returns the \f[I]prngInstance\f[R] command name.
.TP
\f[B]tomcrypt::prng\f[R] \f[B]new\f[R] \f[I]type\f[R] ?\f[I]entropy\f[R]?
As above, but the \f[I]prngInstance\f[R] command name is picked
automatically.
.SS PRNG INSTANCE METHODS
.TP
\f[I]prngInstance\f[R] \f[B]bytes\f[R] \f[I]count\f[R]
Retrieve \f[I]count\f[R] random bytes from the PRNG.
Returned as a raw bytearray.
.TP
\f[I]prngInstance\f[R] \f[B]add_entropy\f[R] \f[I]entropy\f[R]
Add entropy to the PRNG, given as a bytearray \f[I]entropy\f[R], which
should come from a high quality source of random bytes such as the
platform\[cq]s secure RNG or a previously exported state by
\f[I]prngInstance\f[R] \f[B]export\f[R].
.TP
\f[I]prngInstance\f[R] \f[B]integer\f[R] \f[I]lower\f[R] \f[I]upper\f[R]
Generate a random integer between \f[I]lower\f[R] and \f[I]upper\f[R],
inclusive, with uniform distribution.
Either \f[I]lower\f[R] or \f[I]upper\f[R], or both, may be bignums, and
negative, but \f[I]lower\f[R] must be <= \f[I]upper\f[R].
.TP
\f[I]prngInstance\f[R] \f[B]double\f[R]
Generate a random double precision floating point value in the range [0,
1) (inclusive of the lower bound but not the upper).
The result is picked from a set of 2**53 discrete values, with uniform
distribution and equal resolution (uniformly spaced) across the range.
The gap between each discrete value is 2**-53.
This subset - 2/1023 of the possible doubles in [0, 1) - is the largest
subset that satisfies the uniform resolution requirement.
See [1] for a discussion of the nuances of random floating point values.
.TP
\f[I]prngInstance\f[R] \f[B]export\f[R]
Export entropy, returning the random bytearray.
Intended to preserve entropy across PRNG instances and reduce the
demands on scarce platform entropy.
To do that, supply the result of this command to the \f[I]entropy\f[R]
argument when creating a new PRNG instance.
.TP
\f[I]prngInstance\f[R] \f[B]destroy\f[R]
Destroy the instance.
After returning, the \f[I]prngInstance\f[R] command no longer exists and
all resources are released.
Renaming the instance command to {} is equivalent.
.SS CIPHER SPEC
.PP
The choice of cipher and mode for encrypting and decrypting is given by
a list of 3 or 4 elements: \f[I]cipher\f[R], \f[I]keysize\f[R],
\f[I]mode\f[R], and \f[I]mode_opt\f[R] (if the mode takes options).
.PP
\f[I]cipher\f[R] is a name of a symmetric cipher supported by
libtomcrypt, such as \[lq]blowfish\[rq], \[lq]aes\[rq], etc.
\f[I]keysize\f[R] is the size of the key (in bits).
\f[I]mode\f[R] is the streaming mode, such as \[lq]cbc\[rq],
\[lq]ctr\[rq], etc.
Choose \[lq]ctr\[rq] if you don\[cq]t have a good reason not to.
.SS CURVE SPEC
.PP
The curve for ECC operations can be specified by any of the names
libtomcrypt understands: by name like \f[B]secp256r1\f[R], an alias like
\f[B]P-256\f[R], or the OID like \f[B]1.2.840.10045.3.1.7\f[R].
Custom curves can also be specified by a dictionary of parameters with
the following keys: - \f[B]prime\f[R] - \f[B]A\f[R] - \f[B]B\f[R] -
\f[B]order\f[R] - \f[B]Gx\f[R] - \f[B]Gy\f[R] - \f[B]cofactor\f[R]
(optional, defaults to 1) - \f[B]OID\f[R] (optional)
.SS EXAMPLES
.PP
Print out the hex-encoded md5 of \[lq]hello, tomcrypt\[rq] (normally,
when hashing strings, they should be converted to an encoding like utf-8
first, but this example leaves that out for simplicity\[cq]s sake):
.IP
.nf
\f[C]
puts [binary encode hex [tomcrypt::hash md5 \[dq]hello, tomcrypt\[dq]]]
\f[R]
.fi
.PP
Verify an ECC signature:
.IP
.nf
\f[C]
set verified    [tomcrypt::ecc_verify \[rs]
    [binary decode base64 MEUCIQDr/iC/fbEVKDydJ6/Jw95f53b6SGOXo7dMQtVGR48lMQIgeSKKZOph5MMqqj1p/e8NIgIghAe6AoNXir8D6NVwMOo=] \[rs]
    [binary decode hex 41091b1b32c6cd42f06b36f72801e01915bd99115f120c119ef7b781f7140dda] \[rs]
    [binary decode hex 046ddc90ba0fd79c53bd70060192211631d11ec581302e91c3559df4b20cdf747dbd8785a28c30b766e6b43325749ef70a923d0077fbc53cbcbb210de147c540e0] \[rs]
]
if {$verified} {
    puts \[dq]signature is valid\[dq]
} else {
    puts \[dq]signature is not valid\[dq]
}
\f[R]
.fi
.PP
Create a Fortuna PRNG with automatic entropy bootstrapping and use it to
generate 10 random bytearrays:
.IP
.nf
\f[C]
tomcrypt::prng create csprng fortuna
for {set i 0} {$i < 10} {incr i} {
    puts \[dq]random bytes $i: [binary encode hex [csprng bytes 8]]\[dq]
}
csprng destroy
\f[R]
.fi
.PP
Preserve scarce platform entropy between runs, and leave the choice of
the PRNG implementation up to the library, and mix in 8 bytes of entropy
from the platform RNG every 10 minutes:
.IP
.nf
\f[C]
proc readbin filename {
    set h [open $filename rb]
    try {read $h} finally {close $h}
}

proc writebin {filename bytes} {
    set h [open $filename wb]
    try {puts -nonewline $h $bytes} finally {close $h}
}

# Bootstrap using saved entropy if we have it
set saved_entropy_filename  somefile.bin
if {[file exists $saved_entropy_filename]} {
    tomcrypt::prng create csprng {} [readbin $saved_entropy_filename]
} else {
    tomcrypt::prng create csprng {}
}

# Save entropy for next time
writebin $saved_entropy_filename [csprng export]

# Mix in entropy periodically
coroutine background_add_entropy eval {
    trace add command csprng delete [list [info coroutine] done]
    while 1 {
        after [expr {10 * 60 * 1000}] [list [info coroutine] stir]
        switch -- [lindex [yield] 0] {
            stir    { csprng add_entropy [tomcrypt::rng_bytes 8] }
            done    { break }
            default { error \[dq]expecting stir or done\[dq] }
        }
    }
}

# Generate a random 256 bit integer
set key [csprng integer 0 [expr {2**256-1}]]

# Enter the event loop
if {![info exists exit]} {
    vwait exit
}
exit $exit
\f[R]
.fi
.PP
Generate a new ECC keypair and use it to sign a message:
.IP
.nf
\f[C]
tomcrypt::prng create rand fortuna
set msg      [binary decode hex 41091b1b32c6cd42f06b36f72801e01915bd99115f120c119ef7b781f7140dda]
set privkey  [tomcrypt::ecc_generate_key secp256r1 rand]
set pubkey   [tomcrypt::ecc_extract_pubkey $privkey]
set sig      [tomcrypt::ecc_sign $privkey $msg]
set verified [tomcrypt::ecc_verify $sig $msg $pubkey]
if {$verified} {
    puts \[dq]signature verified successfully\[dq]
} else {
    puts \[dq]signature verification failed\[dq]
}
rand destroy
\f[R]
.fi
.PP
Compute HMAC-SHA256:
.IP
.nf
\f[C]
set key     [binary decode hex 0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b]
set message \[dq]Hi There\[dq]
puts [binary encode hex [tomcrypt::hmac sha256 $key $message]]
\f[R]
.fi
.PP
Encrypt and decrypt with AES-GCM authenticated encryption:
.IP
.nf
\f[C]
# Generate a random key and IV
set key [tomcrypt::rng_bytes 32]  ;# 256-bit AES key
set iv  [tomcrypt::rng_bytes 12]  ;# 96-bit IV (recommended for GCM)
set aad \[dq]user-id:12345,timestamp:2024-01-15\[dq]  ;# Metadata to authenticate
set plaintext \[dq]Secret message that needs both confidentiality and authenticity\[dq]

# Encrypt: returns {ciphertext tag}
lassign [tomcrypt::aead encrypt gcm aes $key $iv $aad $plaintext] ciphertext tag

# Store or transmit: $ciphertext, $tag, and $aad
# The IV can be transmitted in the clear (but must not be reused with the same key)

# Decrypt and verify
set decrypted [tomcrypt::aead decrypt gcm aes $key $iv $aad $ciphertext $tag]
puts \[dq]Decrypted: $decrypted\[dq]

# Tag verification failure (tampering detected)
set bad_tag [string repeat \[dq]\[rs]x00\[dq] 16]
if {[catch {tomcrypt::aead decrypt gcm aes $key $iv $aad $ciphertext $bad_tag} err]} {
    puts \[dq]Authentication failed: $err\[dq]
}
\f[R]
.fi
.PP
Generate RSA keypair and create CloudFront-style signature (PKCS#1 v1.5
+ SHA-1):
.IP
.nf
\f[C]
set privkey [tomcrypt::rsa_make_key]
set pubkey [tomcrypt::rsa_extract_pubkey $privkey]

# CloudFront policy string
set policy {{\[dq]Statement\[dq]:[{\[dq]Resource\[dq]:\[dq]http://example.com/*\[dq],\[dq]Condition\[dq]:{\[dq]DateLessThan\[dq]:{\[dq]AWS:EpochTime\[dq]:1234567890}}}]}}
set hash [tomcrypt::hash sha1 [encoding convertto utf-8 $policy]]

# Sign with PKCS#1 v1.5 and SHA-1
set signature [tomcrypt::rsa_sign_hash -key $privkey -hash $hash -padding v1.5 -hashalg sha1]

# Verify signature
set valid [tomcrypt::rsa_verify_hash -key $pubkey -sig $signature -hash $hash -padding v1.5 -hashalg sha1]
if {$valid} {
    puts \[dq]CloudFront signature verified successfully\[dq]
} else {
    puts \[dq]CloudFront signature verification failed\[dq]
}
\f[R]
.fi
.PP
RSA encryption and decryption with OAEP padding:
.IP
.nf
\f[C]
set privkey [tomcrypt::rsa_make_key]
set pubkey [tomcrypt::rsa_extract_pubkey $privkey]

set message \[dq]Secret message for RSA encryption\[dq]
set msgbytes [encoding convertto utf-8 $message]
set lparam \[dq]MyApplication\[dq]
set lparambytes [encoding convertto utf-8 $lparam]

# Encrypt with OAEP padding using SHA-256
set ciphertext [tomcrypt::rsa_encrypt_key -key $pubkey -msg $msgbytes -padding oaep -hashalg sha256 -lparam $lparambytes]

# Decrypt
set decrypted [tomcrypt::rsa_decrypt_key -key $privkey -ciphertext $ciphertext -padding oaep -hashalg sha256 -lparam $lparambytes]
set decrypted_message [encoding convertfrom utf-8 $decrypted]

puts \[dq]Original: $message\[dq]
puts \[dq]Decrypted: $decrypted_message\[dq]
\f[R]
.fi
.PP
RSA signature with PSS padding:
.IP
.nf
\f[C]
set privkey [tomcrypt::rsa_make_key]
set pubkey [tomcrypt::rsa_extract_pubkey $privkey]

set message \[dq]Document to be signed with PSS\[dq]
set hash [tomcrypt::hash sha256 [encoding convertto utf-8 $message]]

# Sign with PSS padding and salt length 32
set signature [tomcrypt::rsa_sign_hash -key $privkey -hash $hash -padding pss -hashalg sha256 -saltlen 32]

# Verify signature
set valid [tomcrypt::rsa_verify_hash -key $pubkey -sig $signature -hash $hash -padding pss -hashalg sha256 -saltlen 32]
if {$valid} {
    puts \[dq]PSS signature verified successfully\[dq]
} else {
    puts \[dq]PSS signature verification failed\[dq]
}
\f[R]
.fi
.SS BUILDING
.PP
This package has no external dependencies other than Tcl.
The libtom libraries it depends on are included as submodules (or baked
into the release tarball) and are built and statically linked as part of
the package build process.
.PP
Currently Tcl 8.7 is required, but if needed polyfills could be built to
support 8.6.
.SS From a Release Tarball
.PP
Download and extract the
release (https://github.com/cyanogilvie/tcl-tomcrypt/releases/download/v0.8.2/tomcrypt0.8.2.tar.gz),
then build in the standard TEA way:
.IP
.nf
\f[C]
wget https://github.com/cyanogilvie/tcl-tomcrypt/releases/download/v0.8.2/tomcrypt0.8.2.tar.gz
tar xf tomcrypt0.8.2.tar.gz
cd tomcrypt0.8.2
\&./configure
make
sudo make install
\f[R]
.fi
.SS From the Git Sources
.PP
Fetch the code (https://github.com/cyanogilvie/tcl-tomcrypt) and
submodules recursively, then build in the standard autoconf / TEA way:
.IP
.nf
\f[C]
git clone --recurse-submodules https://github.com/cyanogilvie/tcl-tomcrypt
cd tcl-tomcrypt
autoconf
\&./configure
make
sudo make install
\f[R]
.fi
.SS In a Docker Build
.PP
Build from a specified release version, avoiding layer pollution and
only adding the installed package without documentation to the image,
and strip debug symbols, minimising image size:
.IP
.nf
\f[C]
WORKDIR /tmp/tcl-tomcrypt
RUN wget https://github.com/cyanogilvie/tcl-tomcrypt/releases/download/v0.8.2/tomcrypt0.8.2.tar.gz -O - | tar xz --strip-components=1 && \[rs]
    ./configure; make test install-binaries install-libraries && \[rs]
    strip /usr/local/lib/libtomcrypt*.so && \[rs]
    cd .. && rm -rf tcl-tomcrypt
\f[R]
.fi
.PP
For any of the build methods you may need to pass
\f[V]--with-tcl /path/to/tcl/lib\f[R] to \f[V]configure\f[R] if your Tcl
install is somewhere nonstandard.
.SS Testing
.PP
Since this package deals with security sensitive code, it\[cq]s a good
idea to run the test suite after building (especially in any automated
build or CI/CD pipeline):
.IP
.nf
\f[C]
make test
\f[R]
.fi
.PP
And maybe also the memory checker \f[V]valgrind\f[R] (requires that Tcl
and this package are built with suitable memory debugging flags, like
\f[V]CFLAGS=\[dq]-DPURIFY -Og\[dq] --enable-symbols\f[R]):
.IP
.nf
\f[C]
make valgrind
\f[R]
.fi
.SS SECURITY
.PP
Given the limitations of a scripting language environment, this
package\[cq]s code does not have sufficient control over freed memory
contents (or memory paged to disk) to guarantee that key material or
other sensitive material (like decrypted messages) can\[cq]t leak in a
way that could be exploited by other code running on the shared memory
(or disk) machine.
For this reason, careful consideration should be given to the security
requirements of the application as a whole when using this package in a
shared execution context, or in a virtual machine.
That said, operations that do not rely on secret values (like verifying
cryptographic signatures) safe in these shared environments.
.SS FUZZING
.PP
TODO
.SS AVAILABLE IN
.PP
The most recent release of this package is available by default in the
\f[V]alpine-tcl\f[R] container image: docker.io/cyanogilvie/alpine-tcl
and the \f[V]cftcl\f[R] Tcl runtime snap:
<https://github.com/cyanogilvie/cftcl>.
.SS SEE ALSO
.PP
This package is built on the libtomcrypt
library (https://github.com/libtom/libtomcrypt), the libtommath
library (https://github.com/libtom/libtommath), and
tomsfastmath (https://github.com/libtom/tomsfastmath).
.SS PROJECT STATUS
.PP
This is a work in progress, but the commands documented here are
implemented and tested and the package is in limited production use.
The ECC related functions are not yet production ready.
.PP
With the nature of this package a lot of care is taken with memory
handling and test coverage.
There are no known memory leaks or errors, and the package is routinely
tested by running its test suite (which aims at full coverage) through
valgrind.
The \f[V]make valgrind\f[R], \f[V]make test\f[R] and
\f[V]make coverage\f[R] build targets support these goals.
.SS SOURCE CODE
.PP
This package\[cq]s source code is available at
<https://github.com/cyanogilvie/tcl-tomcrypt>.
Please create issues there for any bugs discovered.
.SS LICENSE
.PP
This package is placed in the public domain: the author disclaims
copyright and liability to the extent allowed by law.
For those jurisdictions that limit an author\[cq]s ability to disclaim
copyright this package can be used under the terms of the CC0, BSD, or
MIT licenses.
No attribution, permission or fees are required to use this for whatever
you like, commercial or otherwise, though I would urge its users to do
good and not evil to the world.
.SH NOTES
.SS [1]
.PP
Goualard F.
Generating Random Floating-Point Numbers by Dividing Integers: A Case
Study.
Computational Science \[en] ICCS 2020.
2020 Jun 15;12138:15\[en]28.
doi: 10.1007/978-3-030-50417-5_2.
PMCID: PMC7302591.
.SH AUTHORS
Cyan Ogilvie.
