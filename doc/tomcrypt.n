.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "tomcrypt" "3" "" "0.5.2" "libtomcrypt Tcl wrapper"
.hy
.SH TOMCRYPT
.PP
libtomcrypt Tcl wrapper - use cryptographic primitives in Tcl scripts
.SS SYNOPSIS
.PP
\f[B]package require tomcrypt\f[R] ?0.5.2?
.PP
\f[B]tomcrypt::hash\f[R] \f[I]algorithm\f[R] \f[I]bytes\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::ecc_verify\f[R] \f[I]sig\f[R] \f[I]message\f[R]
\f[I]pbkey\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::rng_bytes\f[R] \f[I]count\f[R]
.PD 0
.P
.PD
\f[B]tomcrypt::prng\f[R] \f[B]create\f[R] \f[I]prngInstance\f[R]
\f[I]type\f[R] ?\f[I]entropy\f[R]?
.PD 0
.P
.PD
\f[B]tomcrypt::prng\f[R] \f[B]new\f[R] \f[I]type\f[R]
?\f[I]entropy\f[R]?
.PP
PRNG instance methods:
.PP
\f[I]prngInstance\f[R] \f[B]bytes\f[R] \f[I]count\f[R]
.PD 0
.P
.PD
\f[I]prngInstance\f[R] \f[B]add_entropy\f[R] \f[I]entropy\f[R]
.PD 0
.P
.PD
\f[I]prngInstance\f[R] \f[B]integer\f[R] \f[I]lower\f[R] \f[I]upper\f[R]
.PD 0
.P
.PD
\f[I]prngInstance\f[R] \f[B]double\f[R]
.PD 0
.P
.PD
\f[I]prngInstance\f[R] \f[B]export\f[R]
.PD 0
.P
.PD
\f[I]prngInstance\f[R] \f[B]destroy\f[R]
.SS DESCRIPTION
.PP
This package provides a thin wrapper around a subset of
libtomcrypt\[cq]s functionality.
.SS COMMANDS
.TP
\f[B]tomcrypt::hash\f[R] \f[I]algorithm\f[R] \f[I]bytes\f[R]
Return the hash of \f[I]bytes\f[R], using the \f[I]algorithm\f[R].
The values available for \f[I]algorithm\f[R] are those that are known by
libtomcrypt.
The returned value is the raw bytearray.
.TP
\f[B]tomcrypt::ecc_verify\f[R] \f[I]sig\f[R] \f[I]message\f[R] \f[I]pbkey\f[R]
Verify the signature \f[I]sig\f[R] over the message \f[I]message\f[R]
with public key \f[I]pbkey\f[R].
\f[I]sig\f[R] is in ANSI X9.62 format, \f[I]pbkey\f[R] is in ANSI X9.63
section 4.3.6 format or the native libtomcrypt format, and message is
the raw bytearray (typically a hash result) that was signed.
Returns true if the signature is valid, false if not, and throws an
error if it couldn\[cq]t parse \f[I]sig\f[R] or \f[I]pbkey\f[R].
.TP
\f[B]tomcrypt::prng\f[R] \f[B]create\f[R] \f[I]prngInstance\f[R] \f[I]type\f[R] ?\f[I]entropy\f[R]?
Create a PRNG (pseudorandom number generator) instance accessed by the
command name \f[I]prngInstance\f[R], using the implementation
\f[I]type\f[R], such as \f[B]fortuna\f[R] or \f[B]chacha20\f[R] (as
known to libtomcrypt), or \[dq]\[dq] (an empty string) to select the
recommended default which may change between releases, and bootstrapped
with \f[I]entropy\f[R] which must be a bytearray of high entropy bytes.
If \f[I]entropy\f[R] is omitted the PRNG will be bootstrapped with at
least 256 bits of entropy from the platform\[cq]s default cryptographic
RNG.
Returns the \f[I]prngInstance\f[R] command name.
.TP
\f[B]tomcrypt::prng\f[R] \f[B]new\f[R] \f[I]type\f[R] ?\f[I]entropy\f[R]?
As above, but the \f[I]prngInstance\f[R] command name is picked
automatically.
.SS PRNG INSTANCE METHODS
.TP
\f[I]prngInstance\f[R] \f[B]bytes\f[R] \f[I]count\f[R]
Retrieve \f[I]count\f[R] random bytes from the PRNG.
Returned as a raw bytearray.
.TP
\f[I]prngInstance\f[R] \f[B]add_entropy\f[R] \f[I]entropy\f[R]
Add entropy to the PRNG, given as a bytearray \f[I]entropy\f[R], which
should come from a high quality source of random bytes such as the
platform\[cq]s secure RNG or a previously exported state by
\f[I]prngInstance\f[R] \f[B]export\f[R].
.TP
\f[I]prngInstance\f[R] \f[B]integer\f[R] \f[I]lower\f[R] \f[I]upper\f[R]
Generate a random integer between \f[I]lower\f[R] and \f[I]upper\f[R],
inclusive, with uniform distribution.
Either \f[I]lower\f[R] or \f[I]upper\f[R], or both, may be bignums, and
negative, but \f[I]lower\f[R] must be <= \f[I]upper\f[R].
.TP
\f[I]prngInstance\f[R] \f[B]double\f[R]
Generate a random double precision floating point value in the range [0,
1) (inclusive of the lower bound but not the upper).
The result is picked from a set of 2**53 discrete values, with uniform
distribution and equal resolution (uniformly spaced) across the range.
The gap between each discrete value is 2**-53.
This subset - 2/1023 of the possible doubles in [0, 1) - is the largest
subset that satisfies the uniform resolution requirement.
See [1] for a discussion of the nuances of random floating point values.
.TP
\f[I]prngInstance\f[R] \f[B]export\f[R]
Export entropy, returning the random bytearray.
Intended to preserve entropy across PRNG instances and reduce the
demands on scarce platform entropy.
To do that, supply the result of this command to the \f[I]entropy\f[R]
argument when creating a new PRNG instance.
.TP
\f[I]prngInstance\f[R] \f[B]destroy\f[R]
Destroy the instance.
After returning, the \f[I]prngInstance\f[R] command no longer exists and
all resources are released.
Renaming the instance command to {} is equivalent.
.SS EXAMPLES
.PP
Print out the hex-encoded md5 of \[lq]hello, tomcrypt\[rq] (normally,
when hashing strings, they should be converted to an encoding like utf-8
first, but this example leaves that out for simplicity\[cq]s sake):
.IP
.nf
\f[C]
puts [binary encode hex [tomcrypt::hash md5 \[dq]hello, tomcrypt\[dq]]]
\f[R]
.fi
.PP
Verify an ECC signature:
.IP
.nf
\f[C]
set verified    [tomcrypt::ecc_verify \[rs]
    [binary decode base64 MEUCIQDr/iC/fbEVKDydJ6/Jw95f53b6SGOXo7dMQtVGR48lMQIgeSKKZOph5MMqqj1p/e8NIgIghAe6AoNXir8D6NVwMOo=] \[rs]
    [binary decode hex 41091b1b32c6cd42f06b36f72801e01915bd99115f120c119ef7b781f7140dda] \[rs]
    [binary decode hex 046ddc90ba0fd79c53bd70060192211631d11ec581302e91c3559df4b20cdf747dbd8785a28c30b766e6b43325749ef70a923d0077fbc53cbcbb210de147c540e0] \[rs]
]
if {$verified} {
    puts \[dq]signature is valid\[dq]
} else {
    puts \[dq]signature is not valid\[dq]
}
\f[R]
.fi
.PP
Create a Fortuna PRNG with automatic entropy bootstrapping and use it to
generate 10 random bytearrays:
.IP
.nf
\f[C]
tomcrypt::prng create csprng fortuna
for {set i 0} {$i < 10} {incr i} {
    puts \[dq]random bytes $i: [binary encode hex [csprng bytes 8]]\[dq]
}
csprng destroy
\f[R]
.fi
.PP
Preserve scarce platform entropy between runs, and leave the choice of
the PRNG implementation up to the library, and mix in 8 bytes of entropy
from the platform RNG every 10 minutes:
.IP
.nf
\f[C]
proc readbin filename {
    set h [open $filename rb]
    try {read $h} finally {close $h}
}

proc writebin {filename bytes} {
    set h [open $filename wb]
    try {puts -nonewline $h $bytes} finally {close $h}
}

# Bootstrap using saved entropy if we have it
set saved_entropy_filename  somefile.bin
if {[file exists $saved_entropy_filename]} {
    tomcrypt::prng create csprng {} [readbin $saved_entropy_filename]
} else {
    tomcrypt::prng create csprng {}
}

# Save entropy for next time
writebin $saved_entropy_filename [csprng export]

# Mix in entropy periodically
coroutine background_add_entropy eval {
    trace add command csprng delete [list [info coroutine] done]
    while 1 {
        after [expr {10 * 60 * 1000}] [list [info coroutine] stir]
        switch -- [lindex [yield] 0] {
            stir    { csprng add_entropy [tomcrypt::rng_bytes 8] }
            done    { break }
            default { error \[dq]expecting stir or done\[dq] }
        }
    }
}

# Generate a random 256 bit integer
set key [csprng integer 0 [expr {2**256-1}]]

# Enter the event loop
if {![info exists exit]} {
    vwait exit
}
exit $exit
\f[R]
.fi
.SS BUILDING
.PP
This package has no external dependencies other than Tcl.
The libtom libraries it depends on are included as submodules (or baked
into the release tarball) and are built and statically linked as part of
the package build process.
.PP
Currently Tcl 8.7 is required, but if needed polyfills could be built to
support 8.6.
.SS From a Release Tarball
.PP
Download and extract the
release (https://github.com/cyanogilvie/tcl-tomcrypt/releases/download/v0.5.2/tcl-tomcrypt-v0.5.2.tar.gz),
then build in the standard TEA way:
.IP
.nf
\f[C]
wget https://github.com/cyanogilvie/tcl-tomcrypt/releases/download/v0.5.2/tcl-tomcrypt-v0.5.2.tar.gz
tar xf tcl-tomcrypt-v0.5.2.tar.gz
cd tcl-tomcrypt0.5.2
\&./configure
make
sudo make install
\f[R]
.fi
.SS From the Git Sources
.PP
Fetch the code (https://github.com/cyanogilvie/tcl-tomcrypt) and
submodules recursively, then build in the standard autoconf / TEA way:
.IP
.nf
\f[C]
git clone --recurse-submodules https://github.com/cyanogilvie/tcl-tomcrypt
cd tcl-tomcrypt
autoconf
\&./configure
make
sudo make install
\f[R]
.fi
.SS In a Docker Build
.PP
Build from a specified release version, avoiding layer pollution and
only adding the installed package without documentation to the image,
and strip debug symbols, minimising image size:
.IP
.nf
\f[C]
WORKDIR /tmp/tcl-tomcrypt
RUN wget https://github.com/cyanogilvie/tcl-tomcrypt/releases/download/v0.5.2/tcl-tomcrypt-v0.5.2.tar.gz -O - | tar xz --strip-components=1 && \[rs]
    ./configure; make test install-binaries install-libraries && \[rs]
    strip /usr/local/lib/libtomcrypt*.so && \[rs]
    cd .. && rm -rf tcl-tomcrypt
\f[R]
.fi
.PP
For any of the build methods you may need to pass
\f[C]--with-tcl /path/to/tcl/lib\f[R] to \f[C]configure\f[R] if your Tcl
install is somewhere nonstandard.
.SS Testing
.PP
Since this package deals with security sensitive code, it\[cq]s a good
idea to run the test suite after building (especially in any automated
build or CI/CD pipeline):
.IP
.nf
\f[C]
make test
\f[R]
.fi
.PP
And maybe also the memory checker \f[C]valgrind\f[R] (requires that Tcl
and this package are built with suitable memory debugging flags, like
\f[C]CFLAGS=\[dq]-DPURIFY -Og\[dq] --enable-symbols\f[R]):
.IP
.nf
\f[C]
make valgrind
\f[R]
.fi
.SS SECURITY
.PP
Given the limitations of a scripting language environment, this
package\[cq]s code does not have sufficient control over freed memory
contents (or memory paged to disk) to guarantee that key material or
other sensitive material (like decrypted messages) can\[cq]t leak in a
way that could be exploited by other code running on the shared memory
(or disk) machine.
For this reason, careful consideration should be given to the security
requirements of the application as a whole when using this package in a
shared execution context, or in a virtual machine.
That said, operations that do not rely on secret values (like verifying
cryptographic signatures) safe in these shared environments.
.SS FUZZING
.PP
TODO
.SS AVAILABLE IN
.PP
The most recent release of this package is available by default in the
\f[C]alpine-tcl\f[R] container image: docker.io/cyanogilvie/alpine-tcl
and the \f[C]cftcl\f[R] Tcl runtime snap:
<https://github.com/cyanogilvie/cftcl>.
.SS SEE ALSO
.PP
This package is built on the libtomcrypt
library (https://github.com/libtom/libtomcrypt), the libtommath
library (https://github.com/libtom/libtommath), and
tomsfastmath (https://github.com/libtom/tomsfastmath).
.SS PROJECT STATUS
.PP
This is a very early work in progress.
Currently all that is implemented and tested are the \f[B]hash\f[R] and
\f[B]ecc_verify\f[R] commands.
More to come soon.
.PP
With the nature of this package a lot of care is taken with memory
handling and test coverage.
There are no known memory leaks or errors, and the package is routinely
tested by running its test suite (which aims at full coverage) through
valgrind.
The \f[C]make valgrind\f[R], \f[C]make test\f[R] and
\f[C]make coverage\f[R] build targets support these goals.
.SS SOURCE CODE
.PP
This package\[cq]s source code is available at
<https://github.com/cyanogilvie/tcl-tomcrypt>.
Please create issues there for any bugs discovered.
.SS LICENSE
.PP
This package is placed in the public domain: the author disclaims
copyright and liability to the extent allowed by law.
For those jurisdictions that limit an author\[cq]s ability to disclaim
copyright this package can be used under the terms of the CC0, BSD, or
MIT licenses.
No attribution, permission or fees are required to use this for whatever
you like, commercial or otherwise, though I would urge its users to do
good and not evil to the world.
.SH NOTES
.SS [1]
.PP
Goualard F.
Generating Random Floating-Point Numbers by Dividing Integers: A Case
Study.
Computational Science \[en] ICCS 2020.
2020 Jun 15;12138:15\[en]28.
doi: 10.1007/978-3-030-50417-5_2.
PMCID: PMC7302591.
.SH AUTHORS
Cyan Ogilvie.
